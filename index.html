<script>
/* PumpWolf Dashboard — Moralis Pump.fun (solana-gateway) integration
   Paste this script into your index.html (replace existing script).
   IMPORTANT: replace MORALIS_API_KEY with your real key.
*/

const MORALIS_API_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub25jZSI6Ijc3YTQ1MjhhLTYwY2YtNDJkZi04YzQ1LTgwYThhMmIyNTc1NyIsIm9yZ0lkIjoiNDQwOTM1IiwidXNlcklkIjoiNDUzNjQxIiwidHlwZUlkIjoiOTcyYzFhMjgtZTNkYi00NjIwLWE5Y2MtZmNkODk1ZDFjODgzIiwidHlwZSI6IlBST0pFQ1QiLCJpYXQiOjE3NDQyODU1NjIsImV4cCI6NDkwMDA0NTU2Mn0.u7fKhRKYKuZyArx_DD1fmttQRtT6hXBQwtBOO2XUPaY"; // <-- ganti dengan key-mu
const ENDPOINT = "https://solana-gateway.moralis.io/token/mainnet/exchange/pumpfun/new?limit=100";
const POLL_INTERVAL = 60 * 1000; // 60s

// UI elements (harus ada di HTML)
const tokenContainer = document.getElementById('tokenContainer');
const apiStatusEl = document.getElementById('api-status');
const lastUpdateEl = document.getElementById('last-update');

let pollHandle = null;
let paused = false;

function startPolling(){ stopPolling(); pollHandle = setInterval(fetchAndRender, POLL_INTERVAL); }
function stopPolling(){ if(pollHandle) clearInterval(pollHandle); pollHandle = null; }

// small helper to create sparkline (Chart.js must be loaded)
function makeSparkline(data){
  const canvas = document.createElement('canvas');
  canvas.className = 'spark';
  canvas.style.width = '140px';
  canvas.style.height = '40px';
  const ctx = canvas.getContext('2d');
  new Chart(ctx, {
    type: 'line',
    data: { labels: data.map((_,i)=>i), datasets: [{ data, borderColor: 'rgba(0,240,255,0.9)', borderWidth:1.4, pointRadius:0, fill:false }] },
    options: { responsive:true, maintainAspectRatio:false, elements:{line:{tension:0.25}}, scales:{x:{display:false}, y:{display:false}}, plugins:{legend:{display:false}, tooltip:{enabled:false}} }
  });
  return canvas;
}

function formatNumber(n){
  if(n===null||n===undefined) return '—';
  if(typeof n === 'number') return n.toLocaleString();
  if(!isNaN(Number(n))) return Number(n).toLocaleString();
  return n;
}

function createTokenNode(item){
  // map Moralis fields to our display fields
  const addr = item.tokenAddress || item.address || item.contract_address || '';
  const name = item.name || item.token_name || 'Unknown';
  const symbol = item.symbol || item.ticker || '—';
  const logo = item.logo || '';
  const priceUsd = Number(item.priceUsd || item.price_usd || item.priceUsd) || Number(item.priceUsd || 0);
  const liquidity = Number(item.liquidity || item.liquidity_usd || 0);
  const vol = Number(item.volume_24h || item.volume || 0);
  const holders = item.holders || item.holders_count || '—';

  const card = document.createElement('div');
  card.className = 'token';

  const meta = document.createElement('div');
  meta.className = 'meta';
  const h = document.createElement('h3'); h.innerHTML = `<span class="ticker">${symbol}</span> — ${name}`;
  const p = document.createElement('div'); p.className = 'tiny';
  p.innerHTML = `Price: <b style="color:var(--neon)">$${priceUsd ? priceUsd.toLocaleString() : '—'}</b> &nbsp; • &nbsp; Liquidity: <b>$${formatNumber(liquidity)}</b> &nbsp; • &nbsp; Holders: <b>${holders}</b>`;
  meta.appendChild(h); meta.appendChild(p);

  const sparkWrap = document.createElement('div');
  // create synthetic spark data around priceUsd if no history available
  let sparkData = Array.from({length:20}, (_,i) => (priceUsd || (Math.random()*0.00001)) * (1 + (Math.sin(i/3)*0.002 + (Math.random()-0.5)*0.01)));
  try{
    if(Array.isArray(item.price_history) && item.price_history.length) sparkData = item.price_history.map(x=>Number(x)).slice(-20);
  }catch(e){}

  const spark = makeSparkline(sparkData);
  sparkWrap.appendChild(spark);

  card.appendChild(meta);
  card.appendChild(sparkWrap);

  card.style.cursor = 'pointer';
  card.addEventListener('click', () => {
    if(addr) window.open(`https://pump.fun/coin/${addr}`, '_blank');
  });

  return card;
}

async function fetchAndRender(){
  apiStatusEl.textContent = 'Fetching...';
  try{
    const res = await fetch(ENDPOINT, {
      headers: { "X-API-Key": MORALIS_API_KEY, "accept": "application/json" }
    });
    const text = await res.text();
    if(!res.ok){
      console.warn('Moralis error', res.status, text);
      apiStatusEl.textContent = `Moralis: error ${res.status}`;
      tokenContainer.innerHTML = `<div class="muted">Moralis error ${res.status} — try again later.</div>`;
      lastUpdateEl.textContent = new Date().toLocaleTimeString();
      return;
    }

    const data = JSON.parse(text);
    // response has { result: [ ... ] } per curl -> use data.result
    let items = Array.isArray(data.result) ? data.result : (Array.isArray(data) ? data : (Array.isArray(data.tokens) ? data.tokens : []));
    if(!items || items.length === 0){
      tokenContainer.innerHTML = `<div class="muted">No tokens returned by Moralis right now.</div>`;
      apiStatusEl.textContent = 'Moralis: OK (no tokens)';
      lastUpdateEl.textContent = new Date().toLocaleTimeString();
      return;
    }

    // FILTER: using liquidity threshold as proxy for Level2/3.
    // You can change MIN_LIQUIDITY to any number (e.g., 5000)
    const MIN_LIQUIDITY = 5000;
    const filtered = items.filter(it => {
      const liquidity = Number(it.liquidity || 0);
      return liquidity >= MIN_LIQUIDITY;
    });

    // Sort by liquidity desc
    filtered.sort((a,b) => (Number(b.liquidity||0) - Number(a.liquidity||0)));

    tokenContainer.innerHTML = '';
    if(filtered.length === 0){
      tokenContainer.innerHTML = `<div class="muted">No tokens passed liquidity filter (>= ${MIN_LIQUIDITY}).</div>`;
    } else {
      filtered.forEach(it => tokenContainer.appendChild(createTokenNode(it)));
    }

    apiStatusEl.textContent = 'Moralis: OK';
    lastUpdateEl.textContent = new Date().toLocaleTimeString();

  }catch(err){
    console.error(err);
    apiStatusEl.textContent = 'Moralis: error (network)';
    tokenContainer.innerHTML = `<div class="muted">Network error — check console.</div>`;
    lastUpdateEl.textContent = new Date().toLocaleTimeString();
  }
}

// initial run
fetchAndRender();
startPolling();
</script>
